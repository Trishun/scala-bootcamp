package com.evolutiongaming.bootcamp.streaming.homework

import cats.data.{NonEmptyList => Nel}

/* In Evolution, all our live- and rng- games built on top of Event Sourcing pattern.
 * It allows us to achieve high throughput with a solid reliability, bringing some other bonuses, as data feeding
 * (any downstream consumer can read events stream and process it on their own no affecting main app) and
 * application state reproduction (audit log).
 *
 * Please, read about Event Sourcing here https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing,
 * or watch a presentation by @jkrikis here https://youtu.be/Dw1Di-SGW9A
 *
 * As you see, the main idea in this design approach is to represent entity state as a sequence of events (called events journal)
 * describing changes to state, while state itself stored in memory. Events are generated as a reaction on some external
 * influence (aka Command) arriving to the eventsourced entity. After events was generated, they must be persisted in some storage, applied to
 * existing state to get an actual one and be used to generate some side effects, possibly informing external world about state state or replying
 * to Command.
 *
 * Those command handling flow can be described as follows:
 * 1. Receive command, load any data, required to validate command, from external world
 * 2. Validate command against actual state, producing a list of events and side effect to be ran after events was persisted
 * 3. Persist events
 * 4. Execute side effects
 *
 * Of course, while executing those steps, we must follow some guarantees provided by handling flow,
 *  - commands validation must be ran in the same order they arrives to the entity
 *  - events must be persisted in the same order they was generated
 *  - effects must be executed serially, effect generated by command A must be finished before effect, generated by command B, starts
 *
 * As an example, let's consider Evolution's live game:
 *  - Eventsoursed entity, or aggregate root, is represented by one game table
 *  - Commands are represented by
 *    a. users requests, e.g. to place a bet
 *    b. dealers requests, e.g scan card
 *    c. commands that we send to ourself in order to do state transitions
 *    d. ...
 *  - Events are represented by table state changes, e.g
 *    a. GameStarted
 *    b. BetProcessed
 *    c. CardDealt
 *    d. ...
 *  - Side effects are created from persisted events and usually used to
 *    a. send response on player bet
 *    b. notify game players about game phase transition
 *    c. send player bets to wallets
 *    d. ...
 *
 * I propose you to create such a commands handling flow taking some optimisations into account.
 */

class StreamingHomeWork {

  /** Let's abstract over business logic, we are about to create an engine that is not aware of game specifics
    * hence we ask for game to implement such a GameEngine interface:
    *
    * @tparam F effect type
    * @tparam S state
    * @tparam C command type
    * @tparam E event type
    */
  trait GameEngine[F[_], S, C, E] {
    import GameEngine._

    /** A function representing command validation, we are usually closing over command in `load`
      * so only accept actual state here
      */
    type Validate = S => F[Either[Throwable, CmdDirective[F, S, E]]]

    /** As described above, command handling flow starts with data loading, this data used to validate command against it,
      * for example, on PlaceBet command we are loading table configs to make sure player's bet fits table limits.
      * @param cmd command to handle
      * @param stale potentially stale state, can't be used for exact validation, but for data load instead
      * @return a function, that once having actual state will validate command against it
      */
    def load(cmd: C, stale: S): F[Validate]
  }

  object GameEngine {

    /** Describes new state and events leading to that
      * @param state state after applying events
      * @param events non empty list of events
      */
    final case class Change[S, E](state: S, events: Nel[E])

    /** Describes optional change and effect
      * @param change optional change holding new state and events caused it
      * @param effect effect to be executed after events are stored
      */
    final case class CmdDirective[F[_], S, E](change: Option[Change[S, E]], effect: F[Unit])
  }
}
